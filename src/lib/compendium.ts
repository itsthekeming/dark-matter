import fs from 'fs-extra'
import path from 'path'
import matter from 'gray-matter'

type Article = {
  params: {
    id: string[]
  }
}

// Wrapper to flatten and return nested path list as flat array expected by next
export async function getPathList(
  folder: string,
  originalPath: string,
  pageFileCache: Record<string, string>
): Promise<Article[]> {
  let nestedPaths = await getNestedPathList(folder, originalPath, pageFileCache)
  return flatten(nestedPaths).filter((x) => !!x)
}

// Recursively scan the compendium directory. This includes any extra resolution magic
// such as index.md acting as the folder index
export async function getNestedPathList(
  folder: string,
  ogPath: string,
  pageFileCache: Record<string, string>
): Promise<Article[]> {
  return (
    await Promise.all<Article>(
      (
        await fs.readdir(folder)
      ).map(async (file: string) => {
        const joined = path.join(folder, file)

        // Call recursively if a directory
        if ((await fs.stat(joined)).isDirectory()) {
          return getNestedPathList(joined, ogPath, pageFileCache)
        }

        // If a content markdown is found
        if (joined.endsWith('.md')) {
          let alteredPath = joined
            .slice(folder.length + 1)
            .replace(/\.md$/, '')
            .replace(/\index$/, '')

          // In recursive depths, add folder name and trim any stray '/'
          if (folder !== ogPath) {
            alteredPath = folder.replace(ogPath, '') + '/' + alteredPath
          }

          alteredPath = trimChar(alteredPath, '/')

          pageFileCache[alteredPath] = joined

          return {
            params: {
              id: alteredPath.split('/'),
            },
          }
        } else {
          return null
        }
      })
    )
  ).filter((x: Article) => !!x)
}

export async function getEntryData(id: string, fullPath: string) {
  const fileContents = fs.readFileSync(fullPath, 'utf8') as string

  // Use gray-matter to parse the entry metadata section
  const matterResult = matter(fileContents)

  // Combine the data with the id and content
  return {
    id,
    content: fileContents,
    ...matterResult.data,
  }
}

// helper function useful to quickly print the nested paths while debugging
export function printPaths(paths: Article[], space = '') {
  for (let path of paths) {
    if (!Array.isArray(path)) {
      console.log(space, path.params.id)
    } else {
      printPaths(path, space + ' ')
    }
  }
}

// Generate nested data from nested paths and pageFileCache
// Input paths, pageFileCache generated by getNestedPathList()
function nestData(paths: Article[], pageFileCache: Record<string, string>, start = ['']) {
  // output = {
  //   type: 'folder',
  //   id: '',
  //   path: 'fullpath',
  //   matter: {frontmatter YAML}
  //   files: [
  //     {
  //       type: 'file',
  //       path: 'fullpath'
  //       id: 'slug/id'
  //       matter: ...
  //     },
  //     {
  //       type: 'file',
  //       ...
  //     },
  //     {
  //       type: 'folder',
  //       ...
  //       files: [
  //         ...
  //       ],
  //     },
  //   ]
  // }
  let files = []
  let startPath = pageFileCache[start.join('/')]

  // Remove the element start by compairing ID array
  paths = paths.filter((p) => {
    return (
      Array.isArray(p) ||
      !(
        p.params.id.length === start.length &&
        p.params.id.every((value, index) => value === start[index])
      )
    )
  })

  for (let path of paths) {
    if (!Array.isArray(path)) {
      let id = path.params.id.join('/')
      let fullPath = pageFileCache[id]

      // Use gray-matter to parse the post metadata section
      const fileContents = fs.readFileSync(fullPath, 'utf8')
      const matterResult = matter(fileContents)

      files.push({
        type: 'file',
        id: id,
        path: pageFileCache[id],
        matter: matterResult.data,
      })
    } else {
      // New start will have smallest id length
      let newStart = path.reduce((str, p) => {
        if (!Array.isArray(p)) {
          if (Array.isArray(str)) {
            return p
          }
          return str.params.id.length < p.params.id.length ? str : p
        }
        return str
      }).params.id

      files.push(nestData(path, pageFileCache, newStart))
    }
  }

  // Use gray-matter to parse the post metadata section
  const fileContents = fs.readFileSync(startPath, 'utf8')
  const matterResult = matter(fileContents)

  return {
    type: 'folder',
    id: start.join('/'),
    path: startPath,
    matter: matterResult.data,
    files: files,
  }
}

export async function getFolderNestedData(folder: string) {
  let fullFolderPath = path.join(process.cwd(), '/' + folder)

  const pageFileCache = {}
  const paths = await getNestedPathList(fullFolderPath, fullFolderPath, pageFileCache)

  return nestData(paths, { ...pageFileCache })
}

// Escape special characters for use in a regular expression
function escapeRegExp(strToEscape: string) {
  return strToEscape.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&')
}

// Trim Characters at the start and the end
function trimChar(origString: string, charToTrim: string) {
  charToTrim = escapeRegExp(charToTrim)
  var regEx = new RegExp('^[' + charToTrim + ']+|[' + charToTrim + ']+$', 'g')
  return origString.replace(regEx, '')
}

// Flattens nested arrays
function flatten<TItem>(items: TItem[]) {
  const flat = []

  items.forEach((item) => {
    if (Array.isArray(item)) {
      flat.push(...flatten(item))
    } else {
      flat.push(item)
    }
  })

  return flat
}
